#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'EOF'
Usage:
  ./exec_codex [options] <mode> <issue-id> [extra prompt...]
  ./exec_codex [options] <issue-id> [extra prompt...]

Examples:
  ./exec_codex execution 12
  ./exec_codex execution TRK-12 "テストとコミットまで進めて"
  ./exec_codex 12
  ./exec_codex --isolate 12
  ./exec_codex --full-auto 12
  ./exec_codex --sandbox workspace-write 12

Notes:
  - If mode is omitted, "execution" is used.
  - issue-id accepts numeric form (e.g. 12) or canonical form (e.g. TRK-12).
  - "plan" mode launches interactive Codex CLI so user Q&A is handled in-session.
  - Default is "--sandbox danger-full-access" (GitHub access-friendly).

Options:
  --sandbox <mode>    Override sandbox mode (read-only|workspace-write|danger-full-access)
  --isolate           Run Codex in an isolated git worktree under .worktree/<issue-id>
  --full-auto         Use Codex --full-auto preset
  --bypass            Use --dangerously-bypass-approvals-and-sandbox
EOF
}

if [[ "${1:-}" == "-h" || "${1:-}" == "--help" || $# -lt 1 ]]; then
  usage
  exit 0
fi

if ! command -v codex >/dev/null 2>&1; then
  echo "error: codex command not found in PATH" >&2
  exit 1
fi

repo_root="$(cd "$(dirname "$0")" && pwd)"

sandbox_mode="danger-full-access"
use_isolate="false"
use_full_auto="false"
use_bypass="false"
mode="execution"
issue_id=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    --sandbox)
      if [[ $# -lt 2 ]]; then
        echo "error: --sandbox requires a value" >&2
        usage
        exit 1
      fi
      sandbox_mode="$2"
      shift 2
      ;;
    --full-auto)
      use_full_auto="true"
      shift
      ;;
    --isolate)
      use_isolate="true"
      shift
      ;;
    --bypass)
      use_bypass="true"
      shift
      ;;
    --help|-h)
      usage
      exit 0
      ;;
    *)
      break
      ;;
  esac
done

if [[ $# -ge 2 && ( "$1" == "plan" || "$1" == "execution" ) ]]; then
  mode="$1"
  issue_id="$2"
  shift 2
else
  issue_id="$1"
  shift 1
fi

if [[ -z "$issue_id" ]]; then
  echo "error: issue-id is required" >&2
  usage
  exit 1
fi

target_root="$repo_root"

if [[ "$use_isolate" == "true" ]]; then
  if ! command -v git >/dev/null 2>&1; then
    echo "error: git command not found in PATH (required for --isolate)" >&2
    exit 1
  fi

  issue_slug="$(printf '%s' "$issue_id" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9._-]+/-/g; s/^-+//; s/-+$//')"
  if [[ -z "$issue_slug" ]]; then
    echo "error: unable to derive worktree name from issue-id: $issue_id" >&2
    exit 1
  fi

  worktree_dir="$repo_root/.worktree/$issue_slug"
  worktree_branch="codex/$issue_slug"

  mkdir -p "$repo_root/.worktree"

  if [[ -d "$worktree_dir" ]]; then
    if ! git -C "$worktree_dir" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
      echo "error: existing path is not a git worktree: $worktree_dir" >&2
      exit 1
    fi
  else
    if git -C "$repo_root" show-ref --verify --quiet "refs/heads/$worktree_branch"; then
      git -C "$repo_root" worktree add "$worktree_dir" "$worktree_branch"
    else
      git -C "$repo_root" worktree add -b "$worktree_branch" "$worktree_dir" HEAD
    fi
  fi

  target_root="$worktree_dir"
  export CODEX_HOME="$worktree_dir/.codex-home"
fi

extra_prompt="${*:-}"
plan_body_spec_instruction=""
if [[ "$mode" == "plan" ]]; then
  plan_body_spec_instruction="Plan mode requirement: update the issue body with an implementation-ready, testable Spec (e.g. under '## Spec') before finishing."
fi

prompt=$(
  cat <<EOF
\$track-dev-cycle ${mode} ${issue_id}
${plan_body_spec_instruction}
${extra_prompt}
EOF
)

codex_args=()
if [[ "$use_bypass" == "true" ]]; then
  codex_args+=(--dangerously-bypass-approvals-and-sandbox)
elif [[ "$use_full_auto" == "true" ]]; then
  codex_args+=(--full-auto)
else
  codex_args+=(--sandbox "$sandbox_mode")
fi

if [[ "$mode" == "plan" ]]; then
  exec codex -C "$target_root" "${codex_args[@]}" "$prompt"
fi

exec codex exec -C "$target_root" "${codex_args[@]}" "$prompt"
